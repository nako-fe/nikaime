# -*- coding: utf-8 -*-
"""kakeibo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QgH_yV-6gM4f0-yTTvAF1LBxbhcYZbWh
"""

import streamlit as st
import pandas as pd
from datetime import datetime
import os

# ★追加：データを保存するCSVファイル名を定義
DATA_FILE = "expenses.csv"
SETTINGS_FILE = "settings.csv" # ★追加：設定保存用のファイル名

# --- アプリのタイトル ---
st.title("支出管理アプリ")

# --- セッションステートの初期化 ---
# 支出データを保存するDataFrameを初期化
if "expenses_df" not in st.session_state:
    if os.path.exists(DATA_FILE): # ★変更：ファイルが存在するか確認
        try:
            st.session_state.expenses_df = pd.read_csv(DATA_FILE)
            # ★追加：CSVから読み込んだ日付カラムをdatetime型に変換
            st.session_state.expenses_df["日付"] = pd.to_datetime(st.session_state.expenses_df["日付"])
        except pd.errors.EmptyDataError: # ★追加：ファイルが空の場合の処理
            st.session_state.expenses_df = pd.DataFrame(columns=["日付", "カテゴリ", "金額", "メモ"])
        except Exception as e: # ★追加：その他の読み込みエラーの場合の処理
            st.error(f"データの読み込み中にエラーが発生しました: {e}")
            st.session_state.expenses_df = pd.DataFrame(columns=["日付", "カテゴリ", "金額", "メモ"])
    else: # ★変更：ファイルが存在しない場合
        st.session_state.expenses_df = pd.DataFrame(columns=["日付", "カテゴリ", "金額", "メモ"])

if "categories" not in st.session_state:
    # デフォルトのカテゴリリスト。
    st.session_state.categories = ["食費", "交通費", "娯楽費", "固定費", "その他"]

# 使いすぎラインをセッションステートで管理
if "overspend_limit" not in st.session_state:
    if os.path.exists(SETTINGS_FILE):
        try:
            settings_df = pd.read_csv(SETTINGS_FILE)
            if 'overspend_limit' in settings_df.columns and not settings_df.empty:
                st.session_state.overspend_limit = int(settings_df.loc[0, 'overspend_limit'])
            else:
                st.session_state.overspend_limit = 50000 # ファイルはあるが設定値がない場合
        except Exception as e:
            st.error(f"設定の読み込み中にエラーが発生しました: {e}")
            st.session_state.overspend_limit = 50000 # エラー時はデフォルト値
    else:
        st.session_state.overspend_limit = 50000 # ファイルがない場合はデフォルト値


st.markdown("---") # 区切り線を追加

# --- 使いすぎラインの設定UI ---
st.sidebar.header("設定")
new_limit = st.sidebar.number_input(
    "月間の使いすぎライン (円)",
    min_value=0,
    value=st.session_state.overspend_limit,
    step=1000,
    key="overspend_limit_input" # ユニークなキーを設定
)

# ★追加：CSVファイルにデータを保存する関数
def save_expenses():
    st.session_state.expenses_df.to_csv(DATA_FILE, index=False)
def save_settings():
    settings_df = pd.DataFrame({'overspend_limit': [st.session_state.overspend_limit]})
    settings_df.to_csv(SETTINGS_FILE, index=False)

# 入力値が変更されたらセッションステートを更新し、保存
if new_limit != st.session_state.overspend_limit:
    st.session_state.overspend_limit = new_limit
    save_settings() # ★追加：設定変更時にCSVに保存！
    st.rerun() # ★追加：画面を即座に更新して警告メッセージなどを反映

# --- 支出入力フォーム ---
st.header("新しい支出を記録")

# 入力ウィジェットの作成
# 日付は今日の日付をデフォルトに設定
date = st.date_input("日付", datetime.now())

# カテゴリの選択肢に「新しいカテゴリを追加...」を追加
display_categories = st.session_state.categories + ["新しいカテゴリを追加..."]
selected_category = st.selectbox("カテゴリ", display_categories)

# 「新しいカテゴリを追加...」が選択された場合のみテキスト入力ボックスを表示
if selected_category == "新しいカテゴリを追加...":
    new_custom_category = st.text_input("新しいカテゴリ名を入力してください")
    if st.button("カテゴリを確定"):
        if new_custom_category and new_custom_category not in st.session_state.categories:
            st.session_state.categories.append(new_custom_category)
            # 新しく追加されたカテゴリをデフォルトで選択状態にするため、セッションステートに保存
            st.session_state.last_selected_category = new_custom_category
            st.success(f"カテゴリ「{new_custom_category}」を追加しました！")
            st.rerun() # アプリを再実行して selectbox を更新
        elif new_custom_category in st.session_state.categories:
            st.warning("そのカテゴリは既に存在します。")
        else:
            st.warning("カテゴリ名を入力してください。")
    # カスタムカテゴリが確定されるまでは、選択カテゴリを仮に空白にするか、適切な初期値に設定
    category_to_record = "" # ここでは空にしておき、ユーザーが確定するまで記録しない
else:
    category_to_record = selected_category

amount = st.number_input("金額", min_value=0, value=0, step=100)
memo = st.text_input("メモ (任意)")

# 支出追加ボタン
# 支出追加ボタンが押された際のロジックも調整
if st.button("支出を追加"):
    # 新しいカテゴリ追加の操作中ではないか、またはカテゴリが有効かを確認
    if category_to_record and amount > 0: # category_to_record が空でないことを確認
        # 新しい支出データをDataFrameに追加
        new_expense = pd.DataFrame([{
            "日付": pd.Timestamp(date),
            "カテゴリ": category_to_record, # ここで確定されたカテゴリを使用
            "金額": amount,
            "メモ": memo
        }])
        st.session_state.expenses_df = pd.concat([st.session_state.expenses_df, new_expense], ignore_index=True)
        save_expenses() # ★追加：支出追加後にCSVに保存！
        st.success("支出を記録しました！")
        # 最後に選択・追加したカテゴリを記憶させておくと、次の入力が楽になる
        if selected_category != "新しいカテゴリを追加...": # 新しいカテゴリ追加プロセス中は記憶しない
            st.session_state.last_selected_category = selected_category
        # st.experimental_rerun() # 必要に応じてコメントアウト
    elif amount <= 0:
        st.warning("金額を正しく入力してください。")
    else:
        st.warning("カテゴリを選択または追加してください。") # 新しいカテゴリ追加が未完了の場合


### 記録された支出一覧

st.header("記録された支出")

if not st.session_state.expenses_df.empty:
    # 日付でソート（新しいものが上に来るように降順）
    sorted_df = st.session_state.expenses_df.sort_values(by="日付", ascending=False)
    display_df = sorted_df.copy()
    display_df["日付"] = display_df["日付"].dt.strftime("%Y-%m-%d")
    st.dataframe(display_df, use_container_width=True)

    st.markdown("---")

    # --- 月ごとの支出合計 ---
    st.header("月ごとの支出合計")

    # 日付を年月の形式に変換
    # DatetimeIndex.strftime を推奨
    # pd.to_datetimeは要素ごとにdatetimeオブジェクトに変換、その後にstrftime
    st.session_state.expenses_df["月"] = pd.to_datetime(st.session_state.expenses_df["日付"]).dt.strftime("%Y年%m月")
    monthly_summary = st.session_state.expenses_df.groupby("月")["金額"].sum().reset_index()

    # 月とカテゴリでグループ化して合計金額を計算
    monthly_summary = st.session_state.expenses_df.groupby("月")["金額"].sum().reset_index()
    monthly_summary = monthly_summary.sort_values(by="月", ascending=False) # 月の新しい順にソート

    st.dataframe(monthly_summary, use_container_width=True)

    st.markdown("---")

     # --- 使いすぎ警告の表示 ---
    current_month = datetime.now().strftime("%Y年%m月")
    # 今月の支出合計を計算
    current_month_total = monthly_summary[monthly_summary["月"] == current_month]["金額"].sum()

    if current_month_total > st.session_state.overspend_limit:
        # Markdown を使って警告メッセージを大きく表示
        st.error(f"🚨 **警告！今月の支出は{current_month_total:,.0f}円で、設定ライン({st.session_state.overspend_limit:,.0f}円)を超えています！使いすぎです！**")
    elif current_month_total > st.session_state.overspend_limit * 0.8: # 80%を超えたら注意を促す（オプション）
        st.warning(f"⚠️ 今月の支出は{current_month_total:,.0f}円です。設定ライン({st.session_state.overspend_limit:,.0f}円)に近づいています！")
    else:
        st.success(f"✅ 今月の支出は{current_month_total:,.0f}円です。設定ライン({st.session_state.overspend_limit:,.0f}円)までまだ余裕があります。")
    st.markdown("---") # 警告メッセージの下にも区切り線を追加

    # --- カテゴリ別支出合計 (今月分のみ) ---
    st.header("今月のカテゴリ別支出")

    # 今月のデータを抽出
    current_month = datetime.now().strftime("%Y年%m月")
    this_month_expenses = st.session_state.expenses_df[st.session_state.expenses_df["月"] == current_month]

    if not this_month_expenses.empty:
        category_summary = this_month_expenses.groupby("カテゴリ")["金額"].sum().reset_index()
        st.dataframe(category_summary, use_container_width=True)

        # 円グラフで可視化 (Plotly Express を使用)
        import plotly.express as px
        fig = px.pie(category_summary, values='金額', names='カテゴリ', title=f'{current_month} カテゴリ別支出割合')
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("今月の支出はまだ記録されていません。")

else:
    st.info("まだ支出が記録されていません。上に新しい支出を入力してください。")

# --- アプリ情報（デバッグ用） ---
# st.sidebar.write("現在のデータフレーム:")
# st.sidebar.write(st.session_state.expenses_df)